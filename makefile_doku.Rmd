---
title: "makefile Tutorial"
author: "Manuel Reif"
date: "07. Jänner 2016"
output: html_document
---

Um seine eigenen Daten Analysen nachvollziehbar zu machen, Stichwort: 'reproducible research', ist es hilfreich bestimmte Tools zu verwenden. Mit 'reproducible research' sind in diesem Dokument all jene Bestrebungen nach Nachvollziehbarkeit der Datenanalyse gemeint die über das klassische dokumentieren der Variablen und deren Ausprägungen hinausgehen.

- `knitr` wird verwendet um den Code mit dem Text direkt zu assoziieren - das heisst dass auf einen Blick ins .Rmd/.Rnw klar wird wie die Ergebnisse (Grafiken, Tabellen etc.) entstanden sind. 
- `git` wird verwendet um den Entstehungsprozess der Syntax/Text etc. files nachvollziehbar zu machen
- `makefiles` werden dazu verwendet um die einzelnen Syntaxfiles (bspw. .R/.tex files) und einzelnen Outputfiles miteinander zu verbinden, also die logische Abfolge des Syntaxdurchlaufs zu bestimmen, um zum gewünschten Ergebnis zu kommen. Im sogenannten `Makefile` sind jene Regeln und Abhängigkeiten definiert.


Dieses Tutorial ist vorwiegend dafür gedacht um Makefiles im Rahmen von R und \LaTeX zu verwenden.



### Wann sind Makfiles sinnvoll


Makefiles zu erstellen ist immer sinnvoll, aber insbesondere dann, wenn die Anzahl der zu verbindenden Syntaxfiles steigt, mehrere Outputs realisiert werden sollen (bspw. Grafiken/Bericht/Tabellen etc.) oder die Aufgaben auch von Dritten, die nicht ständig im Projekt sind, leicht zu bewältigen sein sollten. Der Vorteil ist, dass auch bei kleinen Projekten der administrative Aufwand von Makefiles nicht sehr hoch sind, vor allem dann wenn diese von Anfang an angelegt und erweitert werden.



## Aufbau von Makefiles

Ein Makefile ist folgendermaßen aufgebaut:

```
TARGET: Prerequisite1 Prerequisite2   
  Commands
```   

- Target: dieses file wird am Ende erzeugt - Targets enden immer mit einem Doppelpunkt
- Prerequisites: das sind files von denen die Entstehung von Target abhängt. Sind durch ein Leerzeichen getrennt!
- Commands: das ist die Syntax wie das Target erstellt wird. **MÜSSEN IMMER* mit einem **Tabulator** eingerückt sein. Leerzeichen funktionieren **NICHT**!


Wird ein file der **prerequisites** aktualisiert (bspw. ergänzt) und ist damit aktueller als das **target** wird bei einer Eingabe von `make` das Targetfile neu erzeugt mittels der unten stehenden **Commands**.


## Erstes Beispiel

Betrachten wir die Dateien im Ordner `./make1`.

1. In der R Syntax (`syntaxfile1.R`) wird ein plot erzeugt und rausgespeichert
2. Das Makefile stellt den Zusammenhang her.
    a. Target ist das resultierende **pdf** file
    b. Abhängig ist dieses von der Syntax, die dieses file erzeugt (in diesem fall ist dies nur das eine file)
    c. Eine Zeile darunter wird einfach das .R file ausgeführt.
    

Wie geht man nun schrittweise vor:

1. Verzeichnis wechseln nach: ./make1
2. `make` in die Console eintippen
3. Es sollten die Commands ausgeführt werden & Ergebnisfile wird ausgegeben
4. Führt man jetzt **nocheinmal** `make` aus wird nichts mehr passieren (`make: 'mygraphic1.pdf' is up to date.`).


Wir lernen:

1. steht nur ein Eintrag im Makefile, wird dieser mit `make` ausgeführt
2. `make` achtet darauf was ausgeführt werden muss, indem die Erstellungsdaten der files verglichen werden. Wäre unser Syntaxfile nun aktueller als das target, dann führt `make` nochmal die ganze Befehlskette aus



## Zweites Beispiel


Angenommen wir hätten 2 Schritte zu absolvieren:

1. Wir erzeugen/extrahieren die Daten und bereiten diese gegebenenfalls auf und speichern diese
2. Wir lesen diese Daten ein, verarbeiten/analysieren diese und erzeugen grafische Darstellungen
3. Wir wollen auch gleich wieder aufräumen können (unnötige files weg)


Dann brauchen wir mehr als diese Zeilen.

Wir wechseln ins Verzeichnis make2 und sehen uns den Inhalt an.

1. `datenaufbereitung.R` bearbeitet die Daten und schreibt ein `.RData` file raus.
2. `analyse.R` schreibt den plot raus


Diese Abhängigkeiten sind im Makefile dokumentiert. Wir sehen uns das Makefile genau an.

1. Wir haben Schlüsselwörter: **all:** bezeichnet was passiert wenn nur `make` eingetippt wird oder auch `make all`. So kann man mehrere Prozesse definieren, oder bspw. auch nur Teilprozesse ablaufen lassen.
2. Wir sehen 2 Abhängigkeitsdefinitionen
3. Wir definieren 2 clean funktionen die Dateien mit bestimmten Endungen löschen sollen.


### Keywords

Die Allgemeine Logik hinter diesen Keywords sieht so aus:

```
keyword: TARGET

TARGET: Prerequisite1 Prerequisite2   
  Commands
```  


1. Wird `make keyword` aufgerufen, weiss das Programm dass dieses von TARGET abhängt.
2. Also wird TARGET gesucht und geprüft von welchen Dateien dieses abhängt.
3. Ist TARGET aktuell passiert nichts.
4. Ist TARGET nicht aktuell (also älter als eines der Prerequisites) werden die Commands ausgeführt.


### Aufgabe

1. Führe `make` aus, und schau welche Prozesse der Reihe nach ablaufen. Vergleiche dies mit dem Makefile
2. Führe `make` ein weiteres Mal aus, und schau was passiert
3. Führe `make clean` aus und dann nochmal `make` und schau was passiert.
4. Führe `make clean_pdf` aus und dann nochmal `make` und schau was passiert.





### 'automatic variables' zB: $@ etc... plus anwendungsbsp.


### was ist .PHONY plus Anwendungsbsp


### Argumente in R files in Kommandozeile setzen


### handling multiple targets


### klassische (minimale) uebersichtliche Templates zu LaTeX (pur), Rmd/Rnw, R, R und Rmd gemischt etc


### wie funktioniert code externalisation in knitr (finde ich recht praktisch) - weiss nicht ob das zu makefiles passt.











